# 다이나믹 프로그래밍
- **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
- 일반적으로 TopDown(하향식)과 BottomUp(상향식)으로 구성된다.
- **동적 계획법**이라고도 부른다.
- 동적(Dynamic)이란 어떤 의미인가?
  - 자료구조에서 동적 할당은 '**프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법**'을 의미한다.
  - 반면에 다이나믹 프로그래밍에서 '다이나믹'은 **별다른 의미 없이 사용된 단어**이다.
### 다이나믹 프로그래밍의 조건
- 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있다.
  1. **최적 부분 구조 (Optimal Substructure)**
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
  2. **중복되는 부분 문제(Overlapping Subproblem)**
    - 동일한 작은 문제를 반복적으로 해결해야 한다.

- 메모이제이션 (Memoization)
  - TopDown 방법 중 하나
  - 한 번 계산한 결과를 메모리 공간에 메모하는 기법이다.
    - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
    - 값을 기록해 놓는다는 점에서 **캐싱**이라고도 한다.

- TopDown vs BottomUp
  - TopDown(메모이제이션)방식은 **하향식**, BottomUp방식은 **상향식**
  - 다이나믹 프로그래밍의 전형적인 형태는 BottomUp 방식이다.
    - 결과 저장용 리스트는 **DP 테이블**이라고 부른다.
  - 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미
    - 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아니다.
___
### <연습 - 피보나치>
### 단순 재귀
```javascript
function fibo(x) {
  if(x === 1 || x === 2) {
    return 1;
  }
  return fibo(x-1) + fibo(x-2);
}
console.log(fibo(4));
```

### TopDown 다이나믹 프로그래밍
```javascript
const d = [];
for(let i = 0; i < 100; i++) {
  d.push(0);
}

function fibo(x) {
  if(x === 1 || x === 2) {
    return 1;
  }
  if(d[x] !== 0) {
    return d[x]
  }
  d[x] = fibo(x-1) + fibo(x-2);
  return d[x];
}
console.log(fibo(99));
```

### BottomUp 다이나믹 프로그래밍
```javascript
const d = [];
for(let i = 0; i < 100; i++) {
  d.push(0);
}

d[1] = 1;
d[2] = 1;
const n = 99;

for(let i = 3; i < n+1; i++) {
  d[i] = d[i-1] + d[i-2];
}
console.log(d[n])
```
___
### 다이나믹 프로그래밍 문제에 접근하는 방법
- 주어진 문제가 **다이나믹 프로그래밍 유형임을 파악**하는 것이 중요
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토해야 한다.
  - 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려한다.
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운)작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있다.
- **일반 적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제**되는 경우가 많다.
___
### <문제1 - 개미 전사>
- 개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 합니다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있습니다.
- 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정입니다. 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있습니다.
- 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 <U>최소한 한 칸 이상 떨어진 식량창고를 약탈</U>해야 합니다.

```
ex)
예를 들어 식량창고 4개가 다음과 같이 존재한다고 가정합시다.
{1, 3, 1, 5}
```
- 이때 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 <u>총 8개</u>의 식량을 빼앗을 수 있습니다. 개미 전사는 식량창고가 이렇게 일직선상일 때 최대한 많은 식량을 얻기를 원합니다.
- 개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때 **얻을 수 있는 식량의 최댓값**을 구하는 프로그램을 작성하세요.
>Tip) a_i = i번째 식량창고까지의 최적의 해(얻을 수 있는 식량의 최댓값)
> a0 = 1, a1 = 3, a2 = 3, a3 = 8

```javascript
const arr = [1, 3, 1, 5];

const result = [];
result[0] = arr[0];
result[1] = Math.max(arr[0], arr[1]);

for(let i = 2; i < arr.length; i++) {
  result[i] = Math.max(result[i-1], result[i-2]+arr[i])
}
console.log(result[arr.length-1]);
```
___
### <문제2 - 1로 만들기>
- 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지 입니다.
  1. X가 5로 나누어 떨어지면, 5로 나눕니다.
  2. X가 3으로 나누어 떨어지면, 3으로 나눕니다.
  3. X가 2로 나누어 떨어지면, 2로 나눕니다.
  4. X에서 1을 뺍니다.
- 정수 X가 주어져을 때, 연산 4개를 적절히 사용해서 값을 1로 만들고자 합니다. 연산을 사용하는 횟수의 최솟값을 출력하세요. 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값입니다.
  - 26 -> 25 -> 5 -> 1

>Tip) BottomUp으로 1을 뺐을 때와 2, 3, 5로 나누어 떨어졌을 때 중 가장 작은 횟수를 배열에 넣는다.

```javascript
let num = 26;
let d = [0, 0];

for(let i = 2; i <= num; i++) {
  d[i] = d[i - 1] + 1;
  if(i % 2 === 0) {
    d[i] = Math.min(d[i], d[i/2] + 1);
  }
  if(i % 3 === 0) {
    d[i] = Math.min(d[i], d[i/3] + 1);
  }
  if(i % 5 === 0) {
    d[i] = Math.min(d[i], d[i/5] + 1);
  }
}

console.log(d[num])
```
___
### <문제2 - 효율적인 화폐 구성>
- N가지 종류의 화폐가 있습니다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 합니다. 이때 각 종류의 화폐는 몇 개라도 사용할 수 있습니다.
- 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수입니다.
- <u>M원을 만들기 위한 최소한의 화폐 개수</u>를 출력하는 프로그램을 작성하세요.

>Tip) a_i = 금액 i를 만들 수 있는 최소한의 화폐 개수
> k = 각 화폐의 단위
> 점화식: 각 화폐 단위인 k를 하나씩 확인하며
>   - a_i-k를 만드는 방법이 존재하는 경우, a_i = min(a_i,a_i-k + 1)
>   - a_i-k를 만드는 방법이 존재하지 않는 경우, a_i = INF

```javascript

```
___
### <문제3 - 병사 배치하기>
- N명의 병사가 무작위로 나열되어 있습니다. 각 병사는 특정한 값의 전투력을 보유하고 있습니다.
- 병사를 배치할 때는 **전투력이 높은 병사가 앞쪽에 오도록 내림차순으로 배치**를 하고자 합니다. 다시 말해 앞쪽에 있는 병사의 전투력이 항상 뒤쪽에 있는 병사보다 높아야 합니다.
- 또한 배치 과정에서는 특정한 위치에 있는 병사를 열외시키는 방법을 이용합니다. 그러면서도 남아 있는 병사의 수가 최대가 되도록 하고 싶습니다.

>Tip) 

```javascript

```